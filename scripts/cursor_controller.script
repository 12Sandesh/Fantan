local cursor = require "in.cursor"
local logic = require "modules.main"
local dropzones = require "modules.dropzones"
local config = require "modules.config"
local can_drag_card = false
local game_manager = "game:/game_manager#game_manager"
local dropzone_bounds = {}

local LOCAL_PLAYER_ID = config.LOCAL_PLAYER_ID

local card_ranks = {}

local function get_card_property(card_id, property_name)
	local url = msg.url(card_id)
	url.fragment = "card"

	local success, result = pcall(function()
		return go.get(url, property_name)
	end)

	if success then
		return result
	end
	return nil
end

function init(self)
	if not go.get("#cursor", "acquire_input_focus") then
		self.forward_input = true
		msg.post(".", "acquire_input_focus")
	end

	self.over_dropzone = false
	self.current_dropzone = nil
	self.dragging_card = nil
	self.dragging_enabled = false

	cursor.listen(msg.url("#cursor"), cursor.DRAG_START, function(message_id, message)
		if not self.dragging_enabled then
			return true
		end
		-- 1. Get the group directly from your known collision component "card_co"
		local url = msg.url(nil, message.id, "card_co")
		local success, group = pcall(go.get, url, "group")
		local check_group = success and group or message.group

		-- 2. GUARD: Block obvious non-draggable groups
		if check_group == hash("opponentCard") or check_group == hash("dropzone") then
			return true
		end

		-- 3. GUARD: Block if the card is explicitly set to not draggable
		if get_card_property(message.id, "isDraggable") == false then
			return true
		end

		-- 4. GUARD: Block if the card is owned by someone else
		local owner = get_card_property(message.id, "current_player_id")
		if owner and owner ~= 0 and owner ~= LOCAL_PLAYER_ID then
			return true
		end

		-- If it passed all guards, it's a valid playerCard or "card" group drag
		print("✓ Drag Allowed:", message.id)
		return false
	end)
end

function on_input(self, action_id, action)
	if self.forward_input then
		msg.post("#cursor", "input", { action_id = action_id, action = action })
	end
end

function on_message(self, message_id, message, sender)
	if message_id == hash("enable_dragging") then
		self.dragging_enabled = true
		print("Dragging enabled")
		return
	elseif message_id == hash("disable_dragging") then
		self.dragging_enabled = false
		print("Dragging disabled")
		return
	end
	-- NEW: Store card rank when it's registered
	if message_id == hash("register_card_rank") then
		card_ranks[tostring(message.card_id)] = message.rank
		print("Registered card rank:", message.rank, "for card:", message.card_id)
		return
	end

	if message_id == cursor.OVER then
		if message.group == hash("playerCard") then
			-- Show hover effect for player cards
			local p = go.get_position(message.id)
			go.set_position(vmath.vector3(p.x, p.y, 0.9), message.id)
		end

		if message.group == hash("dropzone") then
			self.over_dropzone = true
			self.current_dropzone = message.id

			-- Store dropzone bounds
			local dropzone_pos = go.get_position(message.id)
			local dropzone_size

			-- Try to get sprite size
			local success, result = pcall(function()
				return go.get(msg.url(nil, message.id, "sprite"), "size")
			end)

			if success then
				dropzone_size = result
			else
				success, result = pcall(function()
					return go.get(msg.url(nil, message.id, "dropzone"), "size")
				end)
				if success then
					dropzone_size = result
				else
					dropzone_size = vmath.vector3(400, 200, 0)
				end
			end

			local expand_factor = 1.5
			dropzone_bounds = {
				id = message.id,
				left = dropzone_pos.x - (dropzone_size.x * expand_factor) / 2,
				right = dropzone_pos.x + (dropzone_size.x * expand_factor) / 2,
				bottom = dropzone_pos.y - (dropzone_size.y * expand_factor) / 2,
				top = dropzone_pos.y + (dropzone_size.y * expand_factor) / 2,
				center_x = dropzone_pos.x,
				center_y = dropzone_pos.y,
				width = dropzone_size.x,
				height = dropzone_size.y
			}
		end
	elseif message_id == cursor.OUT then
		if message.group == hash("dropzone") then
			if not self.dragging_card then
				self.over_dropzone = false
				self.current_dropzone = nil
				dropzone_bounds = {}
			end
		end
	elseif message_id == cursor.PRESSED then
		if message.group == hash("playerCard") or message.group == hash("opponentCard") then
			print("=== PRESSED ===")
			print("Card ID:", message.id)
			print("Group:", message.group)

			-- Bring to front immediately
			local current_pos = go.get_position(message.id)
			go.set_position(vmath.vector3(current_pos.x, current_pos.y, 0.9), message.id)

			-- Check if draggable
			if message.group == hash("opponentCard") then
				can_drag_card = false
				print("BLOCKED: opponentCard cannot be dragged")
			elseif message.group == hash("playerCard") then
				local is_draggable = get_card_property(message.id, "isDraggable")
				local current_player_id = get_card_property(message.id, "current_player_id")

				can_drag_card = (is_draggable ~= false) and
					(not current_player_id or current_player_id == LOCAL_PLAYER_ID)

				print("isDraggable:", is_draggable)
				print("Owner ID:", current_player_id)
				print("Final can_drag_card:", can_drag_card)
			end
		end
	elseif message_id == cursor.RELEASED then
		if message.group == hash("playerCard") or message.group == hash("opponentCard") then
			print("=== RELEASED ===")
			can_drag_card = false
			self.dragging_card = nil
		end
	elseif message_id == cursor.DRAG_START then
		print("=== DRAG_START MESSAGE ===")
		self.dragging_card = message.id

		-- SAVE ORIGINAL POSITION for returning on invalid moves
		local card_url = msg.url(message.id)
		card_url.fragment = "card"
		local current_pos = go.get_position(message.id)
		go.set(card_url, "original_pos_x", current_pos.x)
		go.set(card_url, "original_pos_y", current_pos.y)
		go.set(card_url, "original_pos_z", current_pos.z)
		print("Original position saved:", current_pos)
	elseif message_id == cursor.DRAG_END then
		print("=== DRAG_END ===")

		-- Get card position
		local card_pos = go.get_position(message.id)

		-- Get suit under card
		local suit_under_card = dropzones.get_suit_at_pos(card_pos)

		-- Get card rank
		local card_rank_str = card_ranks[tostring(message.id)] or (_G.card_ranks and _G.card_ranks[tostring(message.id)])

		if not card_rank_str or card_rank_str == "" then
			print("ERROR: Could not get card rank")
			self.dragging_card = nil
			return
		end

		local rank, suit = logic.parse_card(card_rank_str)

		-- Check if dropped on correct suit zone
		if suit_under_card == suit then
			print("✓ Card dropped on correct suit zone")

			-- Let game logic handle validation
			local success, snap_pos = logic.request_move(LOCAL_PLAYER_ID, card_rank_str)

			if success and snap_pos then
				-- Snap to position. The z-index will be corrected by the game_manager
				-- after the "card_played" message is processed.
				go.animate(message.id, "position", go.PLAYBACK_ONCE_FORWARD,
					snap_pos, go.EASING_OUTQUAD, 0.2)

				-- Disable dragging on the card itself
				local card_url = msg.url(message.id)
				card_url.fragment = "card"
				go.set(card_url, "isDraggable", false)

				-- Notify game manager about played card
				msg.post(game_manager, "card_played", {
					card_id = message.id,
					suit = suit,
					rank = rank,
					player_id = LOCAL_PLAYER_ID
				})
				
				-- Disable dragging immediately and advance turn
				msg.post(".", "disable_dragging")
				msg.post(game_manager, "advance_turn_request")
			else
				-- Move rejected - return to hand
				print("✗ Move rejected by game logic")
				return_card_to_hand(self, message.id)
			end
		else
			-- Wrong drop zone
			print("✗ Wrong drop zone. Card:", suit, "Zone:", suit_under_card)
			return_card_to_hand(self, message.id)
		end

		self.dragging_card = nil
	end
end

-- Helper function to return card to hand
function return_card_to_hand(self, card_id)
	local card_url = msg.url(card_id)
	card_url.fragment = "card"

	-- 1. Get original properties (including Rotation and Scale for the perspective effect)
	local home_x = get_card_property(card_id, "original_pos_x")
	local home_y = get_card_property(card_id, "original_pos_y")
	local home_z = get_card_property(card_id, "original_pos_z")
	local home_rot = get_card_property(card_id, "original_rot_z") -- The fan angle
	local home_scale = get_card_property(card_id, "original_scale") -- The depth/perspective size

	if home_x and home_y then
		local duration = 0.8
		local easing = go.EASING_OUTQUAD

		-- 2. Animate Position
		local home_pos = vmath.vector3(home_x, home_y, home_z or 0)
		go.animate(card_id, "position", go.PLAYBACK_ONCE_FORWARD, home_pos, easing, duration)

		-- 3. Animate Rotation (Crucial for Bot-2's upside-down fan and Bot-1/3's 90-degree tilt)
		if home_rot then
			-- We animate the Euler Z rotation to fit back into the semi-circle fan
			go.animate(card_id, "euler.z", go.PLAYBACK_ONCE_FORWARD, home_rot, easing, duration)
		end

		-- 4. Animate Scale (Crucial for the "cards further away look smaller" depth effect)
		if home_scale then
			go.animate(card_id, "scale", go.PLAYBACK_ONCE_FORWARD, vmath.vector3(home_scale, home_scale, 1), easing,
				duration)
		end
	else
		print("WARNING: No original position found for " .. tostring(card_id))
	end
end
